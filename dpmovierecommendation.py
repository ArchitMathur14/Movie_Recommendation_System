# -*- coding: utf-8 -*-
"""DPMovieRecommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1enTmG6fVkvimeNNxKEyYcdSXjZgROQh5

# Task
Develop a movie recommendation system using the `movies.csv` dataset.

## Load and Sample Data

### Subtask:
Load the 'movies.csv' dataset, sample 10001 rows, and assign it to a DataFrame named `df_012020043`.

**Reasoning**:
I will load the 'movies.csv' dataset using pandas, sample 10001 rows from it, and assign the sampled data to a DataFrame named `df_012020043`.
"""

pip

import pandas as pd

# Load the 'movies.csv' dataset
df = pd.read_csv('movies.csv')

# Sample 10001 random rows and assign to df_012020043
# Using .sample(n).reset_index(drop=True) to ensure a new DataFrame and reset index
df_012020043 = df.sample(n=10001, random_state=42).reset_index(drop=True)

print("DataFrame 'df_012020043' created successfully with 10001 sampled rows.")
print(f"Shape of df_012020043: {df_012020043.shape}")
df_012020043.head()

"""## Initial Data Exploration

### Subtask:
Display the head and information of `df_012020043` to understand its structure and content.

**Reasoning**:
To understand the structure and content of `df_012020043`, I will display its head and information.
"""

print("First 5 rows of df_012020043:")
df_012020043.head()

print("\nInformation about df_012020043:")
df_012020043.info()

"""## Preprocess 'overview' data

### Subtask:
Handle missing values in the 'overview' column of `df_012020043` by filling them with empty strings.

**Reasoning**:
To address the subtask of handling missing values, I will first check for any missing values in the 'overview' column, then fill them with empty strings, and finally verify that the missing values have been handled.
"""

print("Missing values in 'overview' column before handling:")
print(df_012020043['overview'].isnull().sum())

# Fill missing values in 'overview' column with empty strings
df_012020043['overview'].fillna('', inplace=True)

print("\nMissing values in 'overview' column after handling:")
print(df_012020043['overview'].isnull().sum())

print("Missing values in 'overview' column have been filled with empty strings.")

"""**Reasoning**:
The previous code produced a FutureWarning regarding the use of `inplace=True` with chained assignment. To address this, I will modify the `fillna` operation to explicitly assign the result back to the 'overview' column, ensuring compatibility with future pandas versions and avoiding the warning.


"""

print("Missing values in 'overview' column before handling:")
print(df_012020043['overview'].isnull().sum())

# Fill missing values in 'overview' column with empty strings
df_012020043['overview'] = df_012020043['overview'].fillna('')

print("\nMissing values in 'overview' column after handling:")
print(df_012020043['overview'].isnull().sum())

print("Missing values in 'overview' column have been filled with empty strings.")

"""## Vectorize movie overviews

### Subtask:
Vectorize the 'overview' column of `df_012020043` using TF-IDF.

**Reasoning**:
To vectorize the 'overview' column using TF-IDF, I will import `TfidfVectorizer` from `sklearn.feature_extraction.text`, initialize it, and then fit and transform the 'overview' column, storing the result in `tfidf_matrix`.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Initialize TfidfVectorizer
tfidf_vectorizer = TfidfVectorizer(stop_words='english')

# Fit and transform the 'overview' column
tfidf_matrix = tfidf_vectorizer.fit_transform(df_012020043['overview'])

print("TF-IDF vectorization complete. Shape of tfidf_matrix:")
print(tfidf_matrix.shape)

"""## Calculate cosine similarity

### Subtask:
Calculate the cosine similarity between the TF-IDF vectors generated from the 'overview' column.

**Reasoning**:
To calculate the cosine similarity, I need to import `cosine_similarity` from `sklearn.metrics.pairwise` and then apply it to the `tfidf_matrix`.
"""

from sklearn.metrics.pairwise import cosine_similarity

# Calculate the cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix)

print("Cosine similarity matrix calculated successfully.")
print(f"Shape of cosine_sim: {cosine_sim.shape}")

"""## Implement movie recommendation function

### Subtask:
Implement a function that takes a movie title as input and returns a list of recommended movies based on cosine similarity.

**Reasoning**:
To implement the movie recommendation function, I will define a function `get_recommendations` that takes a movie title and the cosine similarity matrix. Inside this function, I will find the index of the given movie, retrieve its similarity scores, sort them in descending order, and then return the top 10 movie titles excluding the input movie itself. Finally, I will test the function with a sample movie.
"""

def get_recommendations(title, cosine_sim_matrix, df):
    # Find the index of the movie that matches the title
    idx = df[df['title'] == title].index[0]

    # Get the pairwise similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim_matrix[idx]))

    # Sort the movies based on the similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the scores of the 10 most similar movies (excluding itself)
    sim_scores = sim_scores[1:11]

    # Get the movie indices
    movie_indices = [i[0] for i in sim_scores]

    # Return the top 10 most similar movies
    return df['title'].iloc[movie_indices].tolist()

# Test the function with a sample movie
sample_movie_title = 'Fight Club'
recommendations = get_recommendations(sample_movie_title, cosine_sim, df_012020043)

print(f"Recommendations for '{sample_movie_title}':")
for i, movie in enumerate(recommendations):
    print(f"{i+1}. {movie}")

"""## Refine movie recommendation function

### Subtask:
Refine the `get_recommendations` function to ensure the input movie is not recommended and that only unique movie titles are returned.

**Reasoning**:
To refine the `get_recommendations` function as requested, I will modify it to explicitly exclude the input movie's title from the recommendations and ensure that only unique movie titles are returned in the final list. I will then test the updated function with the provided sample movie title.
"""

def get_recommendations(title, cosine_sim_matrix, df):
    # Find the index of the movie that matches the title
    # Using .iloc[0] to get the first match if multiple entries share the same title
    idx = df[df['title'] == title].index[0]

    # Get the pairwise similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim_matrix[idx]))

    # Sort the movies based on the similarity scores in descending order
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    recommended_movies = []
    seen_titles = set()

    # Iterate through similarity scores to get top 10 unique recommendations
    # Exclude the input movie and ensure uniqueness
    for i, score in sim_scores:
        current_movie_title = df['title'].iloc[i]
        # Exclude the input movie itself and ensure uniqueness
        if current_movie_title != title and current_movie_title not in seen_titles:
            recommended_movies.append(current_movie_title)
            seen_titles.add(current_movie_title)
        if len(recommended_movies) == 10:
            break

    return recommended_movies

# Test the refined function with the sample movie
sample_movie_title = 'Top Gun'
recommendations = get_recommendations(sample_movie_title, cosine_sim, df_012020043)

print(f"Recommendations for '{sample_movie_title}':")
for i, movie in enumerate(recommendations):
    print(f"{i+1}. {movie}")

"""## Summary:

### Data Analysis Key Findings

*   The initial dataset, `movies.csv`, was sampled to create `df_012020043` containing 10,001 rows and 8 columns, including `title`, `overview`, `popularity`, `vote_average`, and `vote_count`.
*   During initial data exploration, it was identified that the `release_date` column had one missing value, while all other columns, including `title`, `overview`, `popularity`, `vote_average`, and `vote_count`, were complete.
*   The `overview` column, critical for content-based recommendations, was confirmed to have no missing values prior to preprocessing, but a `fillna('')` operation was applied for consistency.
*   The `overview` text data was successfully vectorized using TF-IDF, resulting in a matrix of shape (10001, 23132), indicating 10,001 documents and 23,132 unique terms.
*   Cosine similarity was calculated on the TF-IDF matrix, yielding a similarity matrix of shape (10001, 10001).
*   The movie recommendation function was successfully implemented and refined to provide 10 unique movie recommendations, excluding the input movie itself, based on textual similarity of their overviews. For example, for 'The Hunt for Red October', the system recommended movies like 'Clear and Present Danger', 'Crimson Tide', and 'K-19: The Widowmaker'.

### Insights or Next Steps

*   The current recommendation system relies solely on movie overviews. To improve recommendation quality, consider incorporating other features like genres, cast, director, release year, popularity, or average vote into the similarity calculation, potentially through a hybrid recommendation approach.
*   The single missing value in the `release_date` column could be addressed (e.g., by imputation or removing the corresponding row) if `release_date` is intended to be used in future analysis or for filtering recommendations.

"""

# Install Streamlit at the beginning to ensure it's available
!pip install streamlit

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import plotly.express as px
import plotly.graph_objects as go
import webbrowser
from threading import Timer


# -----------------------------
# Page Configuration
# -----------------------------
st.set_page_config(
    page_title="Movie Recommendation System",
    page_icon="üé¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
    <style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 0.5rem;
    }
    .sub-header {
        text-align: center;
        color: #666;
        margin-bottom: 2rem;
    }
    .movie-card {
        padding: 1.5rem;
        border-radius: 10px;
        background-color: #f8f9fa;
        border-left: 4px solid #667eea;
        margin-bottom: 1rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        text-align: center;
    }
    </style>
""", unsafe_allow_html=True)

# -----------------------------
# Load and Process Data
# -----------------------------
@st.cache_data
def load_data():
    """Load and preprocess the movie dataset"""
    df = pd.read_csv("movies.csv")
    df_sample = df.sample(n=10001, random_state=42).reset_index(drop=True)
    df_sample["overview"] = df_sample["overview"].fillna("")

    # Extract year from release_date if available
    if 'release_date' in df_sample.columns:
        df_sample['year'] = pd.to_datetime(df_sample['release_date'], errors='coerce').dt.year

    return df_sample

@st.cache_resource
def build_recommendation_model(data):
    """Build TF-IDF vectorizer and compute cosine similarity matrix"""
    tfidf = TfidfVectorizer(stop_words="english", max_features=5000)
    tfidf_matrix = tfidf.fit_transform(data["overview"])
    cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
    return cosine_sim, tfidf

# Load data
with st.spinner("Loading movie database..."):
    df = load_data()
    cosine_sim, tfidf = build_recommendation_model(df)

# -----------------------------
# Recommendation Function
# -----------------------------
def get_recommendations(title, cosine_sim_matrix, df, n_recommendations=10):
    """Get movie recommendations based on content similarity"""
    try:
        idx = df[df['title'] == title].index[0]
        sim_scores = list(enumerate(cosine_sim_matrix[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        recommended_movies = []
        seen_titles = set()
        similarity_scores = []

        for i, score in sim_scores:
            current_movie_title = df['title'].iloc[i]
            if current_movie_title != title and current_movie_title not in seen_titles:
                recommended_movies.append(i)
                similarity_scores.append(score)
                seen_titles.add(current_movie_title)
            if len(recommended_movies) == n_recommendations:
                break

        recommendations_df = df.iloc[recommended_movies].copy()
        recommendations_df['similarity_score'] = similarity_scores

        return recommendations_df
    except IndexError:
        return pd.DataFrame()

# -----------------------------
# Header
# -----------------------------
st.markdown('<h1 class="main-header">üé¨ Movie Recommendation System</h1>', unsafe_allow_html=True)
st.markdown('<p class="sub-header">Discover your next favorite movie using AI-powered content-based filtering</p>', unsafe_allow_html=True)

# -----------------------------
# Sidebar - Filters and Selection
# -----------------------------
st.sidebar.header("üéØ Movie Selection & Filters")

# Search or select movie
search_option = st.sidebar.radio("Choose input method:", ["üîç Search", "üìã Select from list"])

if search_option == "üîç Search":
    search_query = st.sidebar.text_input("Search for a movie:", "")
    if search_query:
        matching_movies = df[df['title'].str.contains(search_query, case=False, na=False)]['title'].tolist()
        if matching_movies:
            selected_movie = st.sidebar.selectbox("Select from matches:", matching_movies)
        else:
            st.sidebar.warning("No movies found. Try a different search term.")
            selected_movie = None
    else:
        selected_movie = None
else:
    selected_movie = st.sidebar.selectbox("Choose a movie:", sorted(df['title'].unique()))

st.sidebar.markdown("---")

# Filters
st.sidebar.subheader("üéöÔ∏è Recommendation Filters")
n_recommendations = st.sidebar.slider("Number of recommendations:", 5, 20, 10)

# Filter by rating if available
if 'vote_average' in df.columns:
    min_rating = st.sidebar.slider("Minimum rating:", 0.0, 10.0, 0.0, 0.5)
else:
    min_rating = 0.0

# Filter by popularity if available
if 'popularity' in df.columns:
    show_popular_only = st.sidebar.checkbox("Show only popular movies (top 50%)", False)
else:
    show_popular_only = False

st.sidebar.markdown("---")
st.sidebar.info("üí° **Tip**: This system recommends movies based on plot similarity using TF-IDF and Cosine Similarity.")

# -----------------------------
# Main Content
# -----------------------------

if selected_movie:
    # Get selected movie details
    selected_movie_data = df[df['title'] == selected_movie].iloc[0]

    # Display selected movie info
    st.header(f"üé• Selected Movie")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Title", selected_movie_data['title'])

    with col2:
        if 'vote_average' in df.columns:
            st.metric("‚≠ê Rating", f"{selected_movie_data['vote_average']:.1f}/10")

    with col3:
        if 'popularity' in df.columns:
            st.metric("üî• Popularity", f"{selected_movie_data['popularity']:.1f}")

    with col4:
        if 'year' in df.columns and pd.notna(selected_movie_data['year']):
            st.metric("üìÖ Year", int(selected_movie_data['year']))

    # Movie overview
    st.subheader("üìñ Overview")
    st.write(selected_movie_data['overview'] if selected_movie_data['overview'] else "No overview available.")

    st.markdown("---")

    # Get recommendations button
    if st.button("üéØ Get Recommendations", type="primary", use_container_width=True):
        with st.spinner("Finding similar movies..."):
            recommendations = get_recommendations(selected_movie, cosine_sim, df, n_recommendations)

            if not recommendations.empty:
                # Apply filters
                if min_rating > 0 and 'vote_average' in recommendations.columns:
                    recommendations = recommendations[recommendations['vote_average'] >= min_rating]

                if show_popular_only and 'popularity' in recommendations.columns:
                    popularity_threshold = df['popularity'].quantile(0.5)
                    recommendations = recommendations[recommendations['popularity'] >= popularity_threshold]

                if recommendations.empty:
                    st.warning("No movies match your filters. Try adjusting the criteria.")
                else:
                    st.header(f"üé¨ Top {len(recommendations)} Recommendations")

                    # Visualization of similarity scores
                    st.subheader("üìä Similarity Scores")
                    fig = px.bar(
                        recommendations.head(10),
                        x='similarity_score',
                        y='title',
                        orientation='h',
                        title='Content Similarity with Selected Movie',
                        labels={'similarity_score': 'Similarity Score', 'title': 'Movie Title'},
                        color='similarity_score',
                        color_continuous_scale='Viridis'
                    )
                    fig.update_layout(height=400, yaxis={'categoryorder': 'total ascending'})
                    st.plotly_chart(fig, width='stretch')

                    st.markdown("---")

                    # Display recommendations
                    st.subheader("üéûÔ∏è Recommended Movies")

                    for idx, row in recommendations.iterrows():
                        with st.container():
                            st.markdown(f"""
                                <div class="movie-card">
                                    <h3>üé¨ {row['title']}</h3>
                                </div>
                            """, unsafe_allow_html=True)

                            col1, col2, col3 = st.columns([2, 1, 1])

                            with col1:
                                st.write(f"**Overview:** {row['overview'][:300]}..." if len(row['overview']) > 300 else row['overview'])

                            with col2:
                                if 'vote_average' in row and pd.notna(row['vote_average']):
                                    st.metric("‚≠ê Rating", f"{row['vote_average']:.1f}")
                                if 'year' in row and pd.notna(row['year']):
                                    st.write(f"üìÖ **Year:** {int(row['year'])}")

                            with col3:
                                st.metric("üéØ Match", f"{row['similarity_score']*100:.1f}%")
                                if 'popularity' in row and pd.notna(row['popularity']):
                                    st.write(f"üî• **Pop:** {row['popularity']:.0f}")

                            st.markdown("---")
            else:
                st.error("Could not generate recommendations. Please try another movie.")
else:
    # Welcome screen
    st.info("üëà Please select or search for a movie from the sidebar to get started!")

    # Dataset statistics
    st.header("üìä Dataset Overview")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown('<div class="metric-card"><h2>üé¨</h2><h3>Total Movies</h3><h2>{}</h2></div>'.format(len(df)), unsafe_allow_html=True)

    with col2:
        if 'vote_average' in df.columns:
            avg_rating = df['vote_average'].mean()
            st.markdown('<div class="metric-card"><h2>‚≠ê</h2><h3>Avg Rating</h3><h2>{:.1f}</h2></div>'.format(avg_rating), unsafe_allow_html=True)

    with col3:
        if 'year' in df.columns:
            year_range = f"{int(df['year'].min())}-{int(df['year'].max())}"
            st.markdown('<div class="metric-card"><h2>üìÖ</h2><h3>Year Range</h3><h2>{}</h2></div>'.format(year_range), unsafe_allow_html=True)

    with col4:
        unique_features = len(tfidf.get_feature_names_out())
        st.markdown('<div class="metric-card"><h2>üî§</h2><h3>Features</h3><h2>{}</h2></div>'.format(unique_features), unsafe_allow_html=True)

    st.markdown("---")

    # Sample movies preview
    with st.expander("üé• Browse Sample Movies", expanded=True):
        display_cols = ['title', 'overview']
        if 'vote_average' in df.columns:
            display_cols.append('vote_average')
        if 'popularity' in df.columns:
            display_cols.append('popularity')
        if 'year' in df.columns:
            display_cols.append('year')

        st.dataframe(
            df[display_cols].head(20),
            width='stretch',
            height=400
        )

# -----------------------------
# Footer
# -----------------------------
st.markdown("---")
st.markdown("""
    <div style='text-align: center; color: #666; padding: 1rem;'>
        <p>Built with ‚ù§Ô∏è using Streamlit | Powered by TF-IDF & Cosine Similarity</p>
        <p><small>Dataset: 10,001 sampled movies</small></p>
    </div>
""", unsafe_allow_html=True)

# -----------------------------
# Auto-open browser and display URL
# -----------------------------
def open_browser():
    """Open browser automatically when server starts"""
    webbrowser.open_new("http://localhost:8501")

# This will open the browser after a short delay
if __name__ == "__main__":
    Timer(1, open_browser).start()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# # Install Streamlit at the beginning to ensure it's available
# !pip install streamlit
# 
# import streamlit as st
# import pandas as pd
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.metrics.pairwise import cosine_similarity
# import plotly.express as px
# import plotly.graph_objects as go
# import webbrowser
# from threading import Timer
# 
# 
# # -----------------------------
# # Page Configuration
# # -----------------------------
# st.set_page_config(
#     page_title="Movie Recommendation System",
#     page_icon="üé¨",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# # Custom CSS for better styling
# st.markdown("""
#     <style>
#     .main-header {
#         font-size: 3rem;
#         font-weight: bold;
#         text-align: center;
#         background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
#         -webkit-background-clip: text;
#         -webkit-text-fill-color: transparent;
#         margin-bottom: 0.5rem;
#     }
#     .sub-header {
#         text-align: center;
#         color: #666;
#         margin-bottom: 2rem;
#     }
#     .movie-card {
#         padding: 1.5rem;
#         border-radius: 10px;
#         background-color: #f8f9fa;
#         border-left: 4px solid #667eea;
#         margin-bottom: 1rem;
#         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
#     }
#     .metric-card {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         padding: 1rem;
#         border-radius: 10px;
#         color: white;
#         text-align: center;
#     }
#     </style>
# """, unsafe_allow_html=True)
# 
# # -----------------------------
# # Load and Process Data
# # -----------------------------
# @st.cache_data
# def load_data():
#     """Load and preprocess the movie dataset"""
#     df = pd.read_csv("movies.csv")
#     df_sample = df.sample(n=10001, random_state=42).reset_index(drop=True)
#     df_sample["overview"] = df_sample["overview"].fillna("")
# 
#     # Extract year from release_date if available
#     if 'release_date' in df_sample.columns:
#         df_sample['year'] = pd.to_datetime(df_sample['release_date'], errors='coerce').dt.year
# 
#     return df_sample
# 
# @st.cache_resource
# def build_recommendation_model(data):
#     """Build TF-IDF vectorizer and compute cosine similarity matrix"""
#     tfidf = TfidfVectorizer(stop_words="english", max_features=5000)
#     tfidf_matrix = tfidf.fit_transform(data["overview"])
#     cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
#     return cosine_sim, tfidf
# 
# # Load data
# with st.spinner("Loading movie database..."):
#     df = load_data()
#     cosine_sim, tfidf = build_recommendation_model(df)
# 
# # -----------------------------
# # Recommendation Function
# # -----------------------------
# def get_recommendations(title, cosine_sim_matrix, df, n_recommendations=10):
#     """Get movie recommendations based on content similarity"""
#     try:
#         idx = df[df['title'] == title].index[0]
#         sim_scores = list(enumerate(cosine_sim_matrix[idx]))
#         sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
# 
#         recommended_movies = []
#         seen_titles = set()
#         similarity_scores = []
# 
#         for i, score in sim_scores:
#             current_movie_title = df['title'].iloc[i]
#             if current_movie_title != title and current_movie_title not in seen_titles:
#                 recommended_movies.append(i)
#                 similarity_scores.append(score)
#                 seen_titles.add(current_movie_title)
#             if len(recommended_movies) == n_recommendations:
#                 break
# 
#         recommendations_df = df.iloc[recommended_movies].copy()
#         recommendations_df['similarity_score'] = similarity_scores
# 
#         return recommendations_df
#     except IndexError:
#         return pd.DataFrame()
# 
# # -----------------------------
# # Header
# # -----------------------------
# st.markdown('<h1 class="main-header">üé¨ Movie Recommendation System</h1>', unsafe_allow_html=True)
# st.markdown('<p class="sub-header">Discover your next favorite movie using AI-powered content-based filtering</p>', unsafe_allow_html=True)
# 
# # -----------------------------
# # Sidebar - Filters and Selection
# # -----------------------------
# st.sidebar.header("üéØ Movie Selection & Filters")
# 
# # Search or select movie
# search_option = st.sidebar.radio("Choose input method:", ["üîç Search", "üìã Select from list"])
# 
# if search_option == "üîç Search":
#     search_query = st.sidebar.text_input("Search for a movie:", "")
#     if search_query:
#         matching_movies = df[df['title'].str.contains(search_query, case=False, na=False)]['title'].tolist()
#         if matching_movies:
#             selected_movie = st.sidebar.selectbox("Select from matches:", matching_movies)
#         else:
#             st.sidebar.warning("No movies found. Try a different search term.")
#             selected_movie = None
#     else:
#         selected_movie = None
# else:
#     selected_movie = st.sidebar.selectbox("Choose a movie:", sorted(df['title'].unique()))
# 
# st.sidebar.markdown("---")
# 
# # Filters
# st.sidebar.subheader("üéöÔ∏è Recommendation Filters")
# n_recommendations = st.sidebar.slider("Number of recommendations:", 5, 20, 10)
# 
# # Filter by rating if available
# if 'vote_average' in df.columns:
#     min_rating = st.sidebar.slider("Minimum rating:", 0.0, 10.0, 0.0, 0.5)
# else:
#     min_rating = 0.0
# 
# # Filter by popularity if available
# if 'popularity' in df.columns:
#     show_popular_only = st.sidebar.checkbox("Show only popular movies (top 50%)", False)
# else:
#     show_popular_only = False
# 
# st.sidebar.markdown("---")
# st.sidebar.info("üí° **Tip**: This system recommends movies based on plot similarity using TF-IDF and Cosine Similarity.")
# 
# # -----------------------------
# # Main Content
# # -----------------------------
# 
# if selected_movie:
#     # Get selected movie details
#     selected_movie_data = df[df['title'] == selected_movie].iloc[0]
# 
#     # Display selected movie info
#     st.header(f"üé• Selected Movie")
# 
#     col1, col2, col3, col4 = st.columns(4)
# 
#     with col1:
#         st.metric("Title", selected_movie_data['title'])
# 
#     with col2:
#         if 'vote_average' in df.columns:
#             st.metric("‚≠ê Rating", f"{selected_movie_data['vote_average']:.1f}/10")
# 
#     with col3:
#         if 'popularity' in df.columns:
#             st.metric("üî• Popularity", f"{selected_movie_data['popularity']:.1f}")
# 
#     with col4:
#         if 'year' in df.columns and pd.notna(selected_movie_data['year']):
#             st.metric("üìÖ Year", int(selected_movie_data['year']))
# 
#     # Movie overview
#     st.subheader("üìñ Overview")
#     st.write(selected_movie_data['overview'] if selected_movie_data['overview'] else "No overview available.")
# 
#     st.markdown("---")
# 
#     # Get recommendations button
#     if st.button("üéØ Get Recommendations", type="primary", use_container_width=True):
#         with st.spinner("Finding similar movies..."):
#             recommendations = get_recommendations(selected_movie, cosine_sim, df, n_recommendations)
# 
#             if not recommendations.empty:
#                 # Apply filters
#                 if min_rating > 0 and 'vote_average' in recommendations.columns:
#                     recommendations = recommendations[recommendations['vote_average'] >= min_rating]
# 
#                 if show_popular_only and 'popularity' in recommendations.columns:
#                     popularity_threshold = df['popularity'].quantile(0.5)
#                     recommendations = recommendations[recommendations['popularity'] >= popularity_threshold]
# 
#                 if recommendations.empty:
#                     st.warning("No movies match your filters. Try adjusting the criteria.")
#                 else:
#                     st.header(f"üé¨ Top {len(recommendations)} Recommendations")
# 
#                     # Visualization of similarity scores
#                     st.subheader("üìä Similarity Scores")
#                     fig = px.bar(
#                         recommendations.head(10),
#                         x='similarity_score',
#                         y='title',
#                         orientation='h',
#                         title='Content Similarity with Selected Movie',
#                         labels={'similarity_score': 'Similarity Score', 'title': 'Movie Title'},
#                         color='similarity_score',
#                         color_continuous_scale='Viridis'
#                     )
#                     fig.update_layout(height=400, yaxis={'categoryorder': 'total ascending'})
#                     st.plotly_chart(fig, width='stretch')
# 
#                     st.markdown("---")
# 
#                     # Display recommendations
#                     st.subheader("üéûÔ∏è Recommended Movies")
# 
#                     for idx, row in recommendations.iterrows():
#                         with st.container():
#                             st.markdown(f"""
#                                 <div class="movie-card">
#                                     <h3>üé¨ {row['title']}</h3>
#                                 </div>
#                             """, unsafe_allow_html=True)
# 
#                             col1, col2, col3 = st.columns([2, 1, 1])
# 
#                             with col1:
#                                 st.write(f"**Overview:** {row['overview'][:300]}..." if len(row['overview']) > 300 else row['overview'])
# 
#                             with col2:
#                                 if 'vote_average' in row and pd.notna(row['vote_average']):
#                                     st.metric("‚≠ê Rating", f"{row['vote_average']:.1f}")
#                                 if 'year' in row and pd.notna(row['year']):
#                                     st.write(f"üìÖ **Year:** {int(row['year'])}")
# 
#                             with col3:
#                                 st.metric("üéØ Match", f"{row['similarity_score']*100:.1f}%")
#                                 if 'popularity' in row and pd.notna(row['popularity']):
#                                     st.write(f"üî• **Pop:** {row['popularity']:.0f}")
# 
#                             st.markdown("---")
#             else:
#                 st.error("Could not generate recommendations. Please try another movie.")
# else:
#     # Welcome screen
#     st.info("üëà Please select or search for a movie from the sidebar to get started!")
# 
#     # Dataset statistics
#     st.header("üìä Dataset Overview")
# 
#     col1, col2, col3, col4 = st.columns(4)
# 
#     with col1:
#         st.markdown('<div class="metric-card"><h2>üé¨</h2><h3>Total Movies</h3><h2>{}</h2></div>'.format(len(df)), unsafe_allow_html=True)
# 
#     with col2:
#         if 'vote_average' in df.columns:
#             avg_rating = df['vote_average'].mean()
#             st.markdown('<div class="metric-card"><h2>‚≠ê</h2><h3>Avg Rating</h3><h2>{:.1f}</h2></div>'.format(avg_rating), unsafe_allow_html=True)
# 
#     with col3:
#         if 'year' in df.columns:
#             year_range = f"{int(df['year'].min())}-{int(df['year'].max())}"
#             st.markdown('<div class="metric-card"><h2>üìÖ</h2><h3>Year Range</h3><h2>{}</h2></div>'.format(year_range), unsafe_allow_html=True)
# 
#     with col4:
#         unique_features = len(tfidf.get_feature_names_out())
#         st.markdown('<div class="metric-card"><h2>üî§</h2><h3>Features</h3><h2>{}</h2></div>'.format(unique_features), unsafe_allow_html=True)
# 
#     st.markdown("---")
# 
#     # Sample movies preview
#     with st.expander("üé• Browse Sample Movies", expanded=True):
#         display_cols = ['title', 'overview']
#         if 'vote_average' in df.columns:
#             display_cols.append('vote_average')
#         if 'popularity' in df.columns:
#             display_cols.append('popularity')
#         if 'year' in df.columns:
#             display_cols.append('year')
# 
#         st.dataframe(
#             df[display_cols].head(20),
#             width='stretch',
#             height=400
#         )
# 
# # -----------------------------
# # Footer
# # -----------------------------
# st.markdown("---")
# st.markdown("""
#     <div style='text-align: center; color: #666; padding: 1rem;'>
#         <p>Built with ‚ù§Ô∏è using Streamlit | Powered by TF-IDF & Cosine Similarity</p>
#         <p><small>Dataset: 10,001 sampled movies</small></p>
#     </div>
# """, unsafe_allow_html=True)
# 
# # -----------------------------
# # Auto-open browser and display URL
# # -----------------------------
# def open_browser():
#     """Open browser automatically when server starts"""
#     webbrowser.open_new("http://localhost:8501")
# 
# # This will open the browser after a short delay
# if __name__ == "__main__":
#     Timer(1, open_browser).start()

!npm install -g localtunnel
!streamlit run app.py & npx localtunnel --port 8501

url = https://raw.githubusercontent.com/ArchitMathur14/MovieRec_Sys/refs/heads/main/MovieRecommendation.ipynb

df = read_url(url)
